<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Travel Destiny</title>
    <!-- Tailwind CSS para un diseño moderno y adaptable -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js para generar el sonido de la alarma -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        /* Importar la fuente Montserrat para el título de la app */
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@700;900&display=swap');

        /* Estilo para asegurar que el mapa ocupe todo el espacio disponible */
        #map {
            height: 100%;
            width: 100%;
        }
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif; /* Fuente 'Inter' para una apariencia moderna */
            overflow: hidden; /* Evita el scroll global del body, ajustado para el layout de la app */
        }
        /* Estilos para el panel de estado flotante (arriba) */
        .status-panel {
            position: absolute;
            top: 10px; /* Arriba */
            left: 50%;
            transform: translateX(-50%);
            z-index: 5;
            background-color: rgba(30, 41, 59, 0.9); /* Azul oscuro para información normal */
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 95%;
            max-width: 500px;
            text-align: center;
            font-weight: 500;
            box-sizing: border-box;
            transition: background-color 0.3s ease-in-out; /* Transición suave para el color de estado */
        }
        /* Estilos para el panel de control flotante (abajo y más pequeño al colapsar) */
        .controls-panel {
            position: absolute;
            bottom: 10px; /* Abajo */
            left: 50%;
            transform: translateX(-50%);
            z-index: 5;
            background-color: rgba(255, 255, 255, 0.8); /* Fondo más transparente */
            padding: 1rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 95%;
            max-width: 500px;
            box-sizing: border-box;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            max-height: 450px; /* Altura máxima AUMENTADA para el panel desplegado */
        }
        .controls-panel.collapsed {
            max-height: 40px; /* Tamaño mucho más pequeño al colapsar */
            padding-top: 0.4rem; /* Ajuste de padding para centrar contenido */
            padding-bottom: 0.4rem;
        }
        /* Ajuste de margen para el título en el panel colapsado */
        .controls-panel.collapsed .app-title {
            margin-bottom: 0 !important; /* Elimina el margen inferior del título */
        }
        .controls-panel .content-wrapper {
            opacity: 1;
            pointer-events: auto;
            overflow: visible;
            height: auto;
            transition: opacity 0.3s ease-out, height 0.3s ease-out;
        }
        .controls-panel.collapsed .content-wrapper {
            opacity: 0;
            pointer-events: none; /* Deshabilita interacciones cuando está colapsado */
            height: 0; /* Colapsa el contenido */
            overflow: hidden;
            padding: 0; /* Asegura que el padding no ocupe espacio cuando colapsa */
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #14b8a6; /* Color calipso (teal-500) */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 0.5rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Enlace para la fuente Montserrat -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;900&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100">

    <!-- Contenedor principal del mapa -->
    <div id="map"></div>

    <!-- Panel para mostrar el estado y la distancia restante (ARRIBA) -->
    <div id="status-panel" class="status-panel hidden">
        <p id="status-text">Esperando destino...</p>
        <p id="route-distance-text" class="text-sm mt-1"></p>
        <div id="loading-indicator" class="mt-2 text-sm hidden">
            <span class="loading-spinner"></span> Cargando...
        </div>
    </div>

    <!-- Panel de control para ingresar destino y distancia (ABAJO) -->
    <div class="controls-panel" id="controls-panel">
        <div class="absolute top-2 right-2 z-10">
            <!-- Botón de toggle con icono de flecha -->
            <button id="toggle-panel-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 text-lg px-2 py-1 rounded-full shadow flex items-center justify-center w-8 h-8">
                <span id="toggle-arrow">&#x25BC;</span> <!-- Flecha hacia abajo (para 'Contraer') -->
            </button>
        </div>
        <!-- Título de la app con nueva fuente y estilos para destacar -->
        <h1 class="text-xl font-extrabold text-teal-700 mb-2 text-center tracking-wider app-title" style="font-family: 'Montserrat', sans-serif;">Travel Destiny</h1>
        <div id="panel-content-wrapper" class="content-wrapper space-y-4">
            <div>
                <label for="start-location-input" class="block text-sm font-medium text-gray-700">Punto de partida:</label>
                <input type="text" id="start-location-input" placeholder="Tu ubicación actual o una dirección" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-teal-500 focus:border-teal-500 sm:text-sm">
                <div class="flex space-x-2 mt-2">
                    <button id="use-current-location-btn" class="w-1/2 bg-teal-500 hover:bg-teal-600 text-white text-sm font-semibold py-1.5 px-3 rounded-md transition duration-300 ease-in-out transform hover:scale-105">
                        Mi ubicación
                    </button>
                    <button id="select-origin-on-map-btn" class="w-1/2 bg-teal-500 hover:bg-teal-600 text-white text-sm font-semibold py-1.5 px-3 rounded-md transition duration-300 ease-in-out transform hover:scale-105">
                        Partida
                    </button>
                </div>
            </div>
            <div>
                <label for="destination-input" class="block text-sm font-medium text-gray-700">Destino:</label>
                <input type="text" id="destination-input" placeholder="Escribe una dirección o haz clic en el mapa" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-teal-500 focus:border-teal-500 sm:text-sm">
                <button id="select-destination-on-map-btn" class="mt-2 w-full bg-teal-500 hover:bg-teal-600 text-white text-sm font-semibold py-1.5 px-3 rounded-md transition duration-300 ease-in-out transform hover:scale-105">
                    Destino
                </button>
            </div>
            <div>
                <label for="distance-input" class="block text-sm font-medium text-gray-700">Avisar a (km):</label>
                <input type="number" id="distance-input" value="1" min="0.1" step="0.1" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-teal-500 focus:border-teal-500 sm:text-sm">
            </div>
            <button id="set-alarm-btn" class="w-full bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 ease-in-out shadow-lg transform hover:scale-105">
                Activar Alarma
            </button>
        </div>
    </div>

    <script>
        // Variables globales
        let map;
        let userMarker; // Marca la ubicación actual del usuario
        let originMarker; // Marca el punto de partida si es diferente de userMarker
        let destinationMarker; // Marca el destino
        let geocoder;
        let directionsService; // Para la API de Directions
        let directionsRenderer; // Para renderizar la ruta
        let startLocation = null; // Coordenadas LatLng del punto de partida de la ruta (puede ser diferente de userMarker)
        let destinationLocation = null; // Coordenadas LatLng del destino
        let alarmDistanceKm = 0;
        let alarmTriggered = false;
        let watchId; // ID para el seguimiento de la geolocalización
        let mapSelectionMode = null; // 'origin' o 'destination' - para clicks en el mapa
        let userPathCoords = []; // Almacena coordenadas para dibujar el trayecto

        // Sintetizador para el sonido de la alarma con Tone.js
        let alarmSynth;

        const startLocationInput = document.getElementById('start-location-input');
        const useCurrentLocationBtn = document.getElementById('use-current-location-btn');
        const selectOriginOnMapBtn = document.getElementById('select-origin-on-map-btn');
        const destinationInput = document.getElementById('destination-input');
        const selectDestinationOnMapBtn = document.getElementById('select-destination-on-map-btn');
        const distanceInput = document.getElementById('distance-input');
        const setAlarmBtn = document.getElementById('set-alarm-btn');
        const controlsPanel = document.getElementById('controls-panel');
        const togglePanelBtn = document.getElementById('toggle-panel-btn');
        const toggleArrow = document.getElementById('toggle-arrow'); // Referencia al span de la flecha
        const panelContentWrapper = document.getElementById('panel-content-wrapper');
        const statusPanel = document.getElementById('status-panel');
        const statusText = document.getElementById('status-text');
        const routeDistanceText = document.getElementById('route-distance-text');
        const loadingIndicator = document.getElementById('loading-indicator');

        // Trayecto del usuario
        let userTrajectoryPolyline;

        /**
         * Función para contraer el panel de control.
         */
        function collapsePanel() {
            controlsPanel.classList.add('collapsed');
            toggleArrow.innerHTML = '&#x25B2;'; // Flecha hacia arriba
        }

        /**
         * Función para expandir el panel de control.
         */
        function expandPanel() {
            controlsPanel.classList.remove('collapsed');
            toggleArrow.innerHTML = '&#x25BC;'; // Flecha hacia abajo
        }

        /**
         * Función principal que inicializa el mapa y la geolocalización.
         * Esta función es llamada por el script de la API de Google Maps una vez que se ha cargado.
         */
        function initMap() {
            const initialPosition = { lat: -33.4489, lng: -70.6693 }; // Santiago, Chile (usado como valor por defecto)

            map = new google.maps.Map(document.getElementById("map"), {
                zoom: 12,
                center: initialPosition,
                mapTypeControl: false,
                streetViewControl: false,
                fullscreenControl: false,
                styles: [], // Se mantienen los estilos vacíos para usar el estilo predeterminado de Google Maps
                mapTypeId: google.maps.MapTypeId.ROADMAP // Siempre se carga como mapa de carretera estándar
            });

            geocoder = new google.maps.Geocoder();
            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer({
                map: map,
                polylineOptions: {
                    strokeColor: '#00BCD4', // Color calipso para la ruta (Cyan 500)
                    strokeOpacity: 0.8,
                    strokeWeight: 6
                },
                suppressMarkers: true // Evita que el renderizador de direcciones ponga sus propios marcadores
            });

            // Configurar el marcador del usuario como una flecha
            userMarker = new google.maps.Marker({
                map: map,
                title: "Tu ubicación actual",
                icon: {
                    path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW, // Forma de flecha
                    scale: 8,
                    fillColor: "#00BCD4", // Color calipso para el marcador de usuario
                    fillOpacity: 1,
                    strokeColor: "white",
                    strokeWeight: 2,
                    rotation: 0 // La rotación se actualizará dinámicamente
                },
            });

            // Inicializar la Polyline para el trayecto del usuario con color gris
            userTrajectoryPolyline = new google.maps.Polyline({
                path: userPathCoords,
                geodesic: true,
                strokeColor: '#AAAAAA', // Color gris para el trayecto del usuario (similar a Google Maps)
                strokeOpacity: 0.7,
                strokeWeight: 4,
                map: map
            });


            // Iniciar el seguimiento de la ubicación del usuario
            startGeolocation();

            // Añadir listener para clics en el mapa para seleccionar puntos
            map.addListener('click', (e) => {
                handleMapClick(e.latLng);
            });

            // Añadir listeners a los botones y campos de entrada
            setAlarmBtn.addEventListener("click", setAlarm);
            useCurrentLocationBtn.addEventListener("click", populateStartWithCurrentLocation);
            selectOriginOnMapBtn.addEventListener("click", () => {
                mapSelectionMode = 'origin';
                updateStatus('Haz clic en el mapa para seleccionar el PUNTO DE PARTIDA.');
                collapsePanel(); // Colapsar el panel al activar selección en mapa
            });
            selectDestinationOnMapBtn.addEventListener("click", () => {
                mapSelectionMode = 'destination';
                updateStatus('Haz clic en el mapa para seleccionar el DESTINO.');
                collapsePanel(); // Colapsar el panel al activar selección en mapa
            });

            // Event listener para el botón de contraer/expandir el panel
            togglePanelBtn.addEventListener("click", () => {
                controlsPanel.classList.toggle('collapsed');
                if (controlsPanel.classList.contains('collapsed')) {
                    toggleArrow.innerHTML = '&#x25B2;'; // Flecha hacia arriba cuando está colapsado
                } else {
                    toggleArrow.innerHTML = '&#x25BC;'; // Flecha hacia abajo cuando está expandido
                }
            });

            // Inicializar Tone.js al interactuar por primera vez con la página
            document.body.addEventListener('click', () => {
                if (!alarmSynth) { // Asegura que el sintetizador solo se cree una vez
                    alarmSynth = new Tone.Synth().toDestination();
                }
            }, { once: true });
        }

        /**
         * Inicia el seguimiento de la geolocalización del dispositivo.
         */
        function startGeolocation() {
            updateStatus('Obteniendo tu ubicación actual...');
            statusPanel.classList.remove('hidden');

            if (navigator.geolocation) {
                watchId = navigator.geolocation.watchPosition(
                    (position) => {
                        const userPos = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude,
                        };
                        
                        userMarker.setPosition(userPos); // Actualiza la posición del marcador del usuario
                        
                        // Actualizar trayecto del usuario y rotación de la flecha
                        userPathCoords.push(userPos);
                        userTrajectoryPolyline.setPath(userPathCoords);

                        // Calcular la rotación de la flecha si hay al menos dos puntos
                        if (userPathCoords.length > 1) {
                            const lastPoint = new google.maps.LatLng(userPathCoords[userPathCoords.length - 2]);
                            const currentPoint = new google.maps.LatLng(userPos.lat, userPos.lng);
                            const heading = google.maps.geometry.spherical.computeHeading(lastPoint, currentPoint);
                            userMarker.setIcon({
                                path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                                scale: 8,
                                fillColor: "#00BCD4",
                                fillOpacity: 1,
                                strokeColor: "white",
                                strokeWeight: 2,
                                rotation: heading // Establece la rotación de la flecha
                            });
                        }
                        
                        // Si startLocation aún no está definido, o si el input de partida está vacío,
                        // actualizar el input de partida y la variable startLocation con la ubicación actual
                        if (!startLocation || startLocationInput.value === '') {
                             startLocation = new google.maps.LatLng(userPos.lat, userPos.lng);
                             if (startLocationInput.value === '') { // Solo geocodificar y rellenar si está vacío
                                 geocodeLocation(startLocation).then(result => {
                                     if (result) startLocationInput.value = result.formatted_address;
                                 }).catch(e => console.warn("No se pudo geocodificar la ubicación inicial:", e));
                             }
                        }

                        // Centra el mapa en el usuario al inicio o si el usuario sale del foco del mapa
                        if (map.getZoom() < 10 || !map.getBounds().contains(userPos)) {
                            map.setCenter(userPos);
                            map.setZoom(15);
                        }

                        if (destinationLocation) {
                            checkDistance(userPos); // La alarma siempre se basa en la ubicación *actual* del usuario
                        } else {
                            updateStatus('Ubicación actual obtenida. Establece un destino.');
                        }
                    },
                    (error) => {
                        handleLocationError(error);
                    },
                    {
                        enableHighAccuracy: true,
                        maximumAge: 0,
                        timeout: 5000
                    }
                );
            } else {
                handleLocationError(null);
            }
        }

        /**
         * Rellena el input de partida con la dirección actual del usuario.
         */
        async function populateStartWithCurrentLocation() {
            if (userMarker.getPosition()) {
                const userPos = userMarker.getPosition();
                startLocation = userPos; // Establece la variable startLocation a la ubicación actual
                try {
                    const result = await geocodeLocation(userPos);
                    startLocationInput.value = result.formatted_address;
                    updateStatus("Ubicación actual establecida como punto de partida.");
                    // Si ya hay un destino, recalcular la ruta
                    if (destinationLocation) {
                        calculateAndDisplayRoute(startLocation, destinationLocation);
                    }
                } catch (error) {
                    updateStatus("No se pudo obtener la dirección de tu ubicación actual.", 'error');
                    console.error("Error geocodificando ubicación actual:", error);
                }
            } else {
                updateStatus("Esperando tu ubicación actual...", 'info');
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const userPos = { lat: position.coords.latitude, lng: position.coords.longitude };
                        userMarker.setPosition(userPos);
                        populateStartWithCurrentLocation();
                    },
                    (error) => {
                        updateStatus("No se pudo obtener tu ubicación para establecerla como partida.", 'error');
                        console.error("Error al obtener ubicación:", error);
                    }
                );
            }
        }

        /**
         * Maneja los errores de geolocalización.
         * @param {GeolocationPositionError} error - El objeto de error de geolocalización.
         */
        function handleLocationError(error) {
            statusPanel.classList.remove('hidden');
            statusPanel.style.backgroundColor = '#DC2626';

            let errorMessage = 'Error desconocido al obtener la ubicación.';
            if (error) {
                switch (error.code) {
                    case error.PERMISSION_DENIED:
                        errorMessage = "Error: Permiso de geolocalización denegado. Por favor, permite el acceso a la ubicación.";
                        break;
                    case error.POSITION_UNAVAILABLE:
                        errorMessage = "Error: La información de ubicación no está disponible.";
                        break;
                    case error.TIMEOUT:
                        errorMessage = "Error: Tiempo de espera para obtener la ubicación agotado.";
                        break;
                    default:
                        errorMessage = `Error de geolocalización: ${error.message}`;
                }
            } else {
                errorMessage = "Error: Tu navegador no soporta geolocalización.";
            }
            updateStatus(errorMessage);
        }

        /**
         * Geocodifica una dirección o coordenadas (LatLng).
         * @param {string|google.maps.LatLng} addressOrLatLng - Dirección como string o coordenadas LatLng.
         * @returns {Promise<google.maps.GeocoderResult>} Resultado de la geocodificación.
         */
        async function geocodeLocation(addressOrLatLng) {
            showLoading(true);
            return new Promise((resolve, reject) => {
                let request;
                if (typeof addressOrLatLng === 'string') {
                    request = { address: addressOrLatLng };
                } else {
                    request = { location: addressOrLatLng };
                }

                geocoder.geocode(request, (results, status) => {
                    showLoading(false);
                    if (status === 'OK' && results[0]) {
                        resolve(results[0]);
                    } else {
                        reject(`Geocodificación fallida: ${status}`);
                    }
                });
            });
        }

        /**
         * Calcula y muestra la ruta entre dos puntos en el mapa.
         * También actualiza la distancia de la ruta.
         * @param {google.maps.LatLng} origin - Coordenadas del punto de origen.
         * @param {google.maps.LatLng} destination - Coordenadas del punto de destino.
         */
        function calculateAndDisplayRoute(origin, destination) {
            routeDistanceText.textContent = ''; // Limpiar texto de distancia anterior
            if (!origin || !destination) {
                updateStatus('No se pudo calcular la ruta: falta origen o destino.', 'error');
                directionsRenderer.setDirections({ routes: [] });
                ensureMarkersVisibleWithoutRoute();
                return;
            }

            directionsService.route(
                {
                    origin: origin,
                    destination: destination,
                    travelMode: google.maps.TravelMode.DRIVING
                },
                (response, status) => {
                    if (status === 'OK' && response.routes[0]) {
                        directionsRenderer.setDirections(response);
                        // userMarker.setMap(null); // No ocultar el marcador del usuario
                        if (originMarker) originMarker.setMap(null);
                        if (destinationMarker) destinationMarker.setMap(null); 

                        const route = response.routes[0];
                        const distanceText = route.legs[0].distance.text;
                        routeDistanceText.textContent = `Distancia en ruta: ${distanceText}`;
                        updateStatus('Ruta calculada y mostrada.');
                    } else {
                        directionsRenderer.setDirections({ routes: [] });
                        console.error('Error al calcular la ruta:', status);
                        updateStatus(`Error al calcular la ruta: ${status}. Intenta con otras direcciones.`, 'error');
                        ensureMarkersVisibleWithoutRoute();
                    }
                }
            );
        }

        /**
         * Asegura que los marcadores de usuario, origen y destino sean visibles si no hay una ruta activa.
         */
        function ensureMarkersVisibleWithoutRoute() {
            userMarker.setMap(map); // Siempre mostrar el marcador del usuario
            // Restablecer el icono de la flecha a su configuración predeterminada si no hay ruta
            userMarker.setIcon({
                path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                scale: 8,
                fillColor: "#00BCD4",
                fillOpacity: 1,
                strokeColor: "white",
                strokeWeight: 2,
                rotation: 0 // Restablecer rotación
            });
            userTrajectoryPolyline.setPath([]); // Limpiar el trayecto
            userPathCoords = []; // Resetear las coordenadas del trayecto
            
            if (startLocation && userMarker.getPosition() && !userMarker.getPosition().equals(startLocation)) {
                if (!originMarker) {
                    originMarker = new google.maps.Marker({
                        position: startLocation,
                        map: map,
                        title: 'Punto de Partida',
                        icon: { url: 'https://maps.google.com/mapfiles/ms/icons/green-dot.png' }
                    });
                } else {
                    originMarker.setPosition(startLocation);
                    originMarker.setMap(map);
                }
            } else if (originMarker) {
                originMarker.setMap(null);
            }

            if (destinationLocation) {
                if (!destinationMarker) {
                    destinationMarker = new google.maps.Marker({
                        position: destinationLocation,
                        map: map,
                        title: 'Destino',
                        icon: { url: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png' }
                    });
                } else {
                    destinationMarker.setPosition(destinationLocation);
                    destinationMarker.setMap(map);
                }
            } else if (destinationMarker) {
                destinationMarker.setMap(null);
            }
        }

        /**
         * Maneja el clic en el mapa para establecer un destino o un punto de partida.
         * @param {google.maps.LatLng} latLng - Coordenadas del punto donde se hizo clic.
         */
        async function handleMapClick(latLng) {
            try {
                const result = await geocodeLocation(latLng);
                const selectedLocation = result.geometry.location;
                const formattedAddress = result.formatted_address;

                if (mapSelectionMode === 'origin') {
                    startLocation = selectedLocation;
                    startLocationInput.value = formattedAddress;
                    if (originMarker) originMarker.setMap(null);
                    if (userMarker.getPosition() && !userMarker.getPosition().equals(selectedLocation)) {
                        originMarker = new google.maps.Marker({
                            position: startLocation,
                            map: map,
                            title: 'Punto de Partida',
                            icon: { url: 'https://maps.google.com/mapfiles/ms/icons/green-dot.png' }
                        });
                    }
                    userMarker.setMap(map);
                    updateStatus(`Punto de partida seleccionado en el mapa: ${formattedAddress}`);
                } else { // mapSelectionMode es 'destination' o null (comportamiento por defecto)
                    destinationLocation = selectedLocation;
                    destinationInput.value = formattedAddress;
                    if (destinationMarker) destinationMarker.setMap(null);
                    destinationMarker = new google.maps.Marker({
                        position: destinationLocation,
                        map: map,
                        title: 'Destino',
                        icon: { url: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png' }
                    });
                    updateStatus(`Destino seleccionado en el mapa: ${formattedAddress}`);
                }

                map.setCenter(selectedLocation);
                map.setZoom(14);
                alarmTriggered = false; // Resetear alarma si se cambia el destino

                let currentRouteOrigin = startLocation || userMarker.getPosition();
                if (currentRouteOrigin && destinationLocation) {
                    calculateAndDisplayRoute(currentRouteOrigin, destinationLocation);
                } else {
                    updateStatus('Punto fijado. Ahora define el otro punto o espera la ubicación actual.', 'info');
                }
                mapSelectionMode = null;
                expandPanel();
            }
            catch (error) {
                updateStatus(`Error al seleccionar punto en el mapa: ${error}. Por favor, intenta de nuevo.`, 'error');
                console.error(error);
                mapSelectionMode = null;
                expandPanel();
            }
        }

        /**
         * Se ejecuta al pulsar el botón "Activar Alarma".
         * Obtiene la dirección de partida y destino, y establece la la alarma.
         */
        async function setAlarm() {
            const startAddress = startLocationInput.value.trim();
            const destAddress = destinationInput.value.trim();
            const distance = parseFloat(distanceInput.value);

            if (!startAddress && !userMarker.getPosition()) {
                updateStatus("No se ha podido obtener tu ubicación actual y no hay un punto de partida manual. Espera o introduce una dirección de partida.", 'error');
                return;
            }

            if (!destAddress || isNaN(distance) || distance <= 0) {
                updateStatus("Por favor, introduce un destino válido y una distancia mayor a 0.", 'error');
                return;
            }

            try {
                let routeOriginLatLng;
                if (startAddress) {
                    const startResult = await geocodeLocation(startAddress);
                    routeOriginLatLng = startResult.geometry.location;
                    startLocation = routeOriginLatLng;

                    if (originMarker) originMarker.setMap(null);
                    if (userMarker.getPosition() && !userMarker.getPosition().equals(routeOriginLatLng)) {
                        originMarker = new google.maps.Marker({
                            position: routeOriginLatLng,
                            map: map,
                            title: 'Punto de Partida',
                            icon: { url: 'https://maps.google.com/mapfiles/ms/icons/green-dot.png' }
                        });
                    } else if (!userMarker.getPosition() && routeOriginLatLng) {
                         originMarker = new google.maps.Marker({
                            position: routeOriginLatLng,
                            map: map,
                            title: 'Punto de Partida',
                            icon: { url: 'https://maps.google.com/mapfiles/ms/icons/green-dot.png' }
                        });
                    }
                } else {
                    routeOriginLatLng = userMarker.getPosition();
                    startLocation = routeOriginLatLng;
                    if (originMarker) originMarker.setMap(null);
                }
                
                const destinationResult = await geocodeLocation(destAddress);
                destinationLocation = destinationResult.geometry.location;
                alarmDistanceKm = distance;
                alarmTriggered = false;

                directionsRenderer.setDirections({ routes: [] });
                userTrajectoryPolyline.setPath([]); // Limpiar trayecto al establecer nueva alarma
                userPathCoords = [];

                if (destinationMarker) {
                    destinationMarker.setPosition(destinationLocation);
                    destinationMarker.setMap(map);
                } else {
                    destinationMarker = new google.maps.Marker({
                        position: destinationLocation,
                        map: map,
                        title: "Destino",
                        animation: google.maps.Animation.DROP,
                        icon: {
                            url: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png'
                        }
                    });
                }
                map.setCenter(destinationLocation);
                map.setZoom(14);

                updateStatus(`Destino fijado: ${destinationResult.formatted_address}. Alarma sonará a ${alarmDistanceKm} km.`);

                calculateAndDisplayRoute(routeOriginLatLng, destinationLocation);

            } catch (error) {
                updateStatus(`Error al establecer el origen o destino: ${error}. Por favor, verifica las direcciones.`, 'error');
                console.error(error);
            }
        }

        /**
         * Calcula la distancia entre la ubicación del usuario y el destino.
         * Si la distancia es menor a la establecida, dispara la alarma.
         * @param {object} userPos - Objeto con las coordenadas {lat, lng} del usuario.
         */
        function checkDistance(userPos) {
            if (!destinationLocation || alarmTriggered) return;

            const userLatLng = new google.maps.LatLng(userPos.lat, userPos.lng);
            
            const distanceInMeters = google.maps.geometry.spherical.computeDistanceBetween(userLatLng, destinationLocation);
            const distanceInKm = distanceInMeters / 1000;

            updateStatus(`Distancia al destino: ${distanceInKm.toFixed(2)} km.`);

            if (distanceInKm <= alarmDistanceKm) {
                triggerAlarm();
                alarmTriggered = true;
            }
        }

        /**
         * Actualiza el texto en el panel de estado y su color si es un error.
         * También oculta el texto de distancia de ruta si se muestra un error.
         * @param {string} text - El mensaje a mostrar.
         * @param {string} type - Tipo de mensaje ('info' o 'error').
         */
        function updateStatus(text, type = 'info') {
            statusPanel.classList.remove('hidden');
            
            if (type === 'error') {
                statusPanel.style.backgroundColor = '#DC2626';
                routeDistanceText.textContent = '';
            } else {
                statusPanel.style.backgroundColor = 'rgba(30, 41, 59, 0.9)';
            }
            statusText.textContent = text;
        }

        /**
         * Muestra u oculta el indicador de carga.
         * @param {boolean} show - True para mostrar, false para ocultar.
         */
        function showLoading(show) {
            if (show) {
                loadingIndicator.classList.remove('hidden');
            } else {
                loadingIndicator.classList.add('hidden');
            }
        }

        /**
         * Activa la alarma: reproduce un sonido y muestra un mensaje.
         */
        function triggerAlarm() {
            updateStatus(`¡ALERTA! Estás a menos de ${alarmDistanceKm} km de tu destino.`, 'info');
            statusPanel.style.backgroundColor = '#16A34A';

            if (alarmSynth && Tone.context.state !== 'running') {
                Tone.start();
            }
            
            if (alarmSynth) {
                const now = Tone.now();
                alarmSynth.triggerAttackRelease("C5", "8n", now);
                alarmSynth.triggerAttackRelease("G5", "8n", now + 0.2);
                alarmSynth.triggerAttackRelease("C5", "8n", now + 0.4);
            }

            if (window.navigator && window.navigator.vibrate) {
                navigator.vibrate([500, 200, 500]);
            }
        }

        // Exportar initMap al ámbito global para que la API de Google Maps pueda llamarla
        window.initMap = initMap;
    </script>
    
    <!-- Script de la API de Google Maps con tu clave ya insertada -->
    <!-- Se añaden las librerías 'places' y 'directions' explícitamente y se especifica la versión 'weekly' -->
    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDtcqVqcrFrSU8KdDaLpQZQmieLFtScKmQ&loading=async&libraries=geometry,places,directions&v=weekly&callback=initMap">
    </script>
</body>
</html>
